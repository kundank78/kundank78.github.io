"use strict";(self.webpackChunkkundan_dev=self.webpackChunkkundan_dev||[]).push([[477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"cheeat-sheet-ckad","metadata":{"permalink":"/blog/cheeat-sheet-ckad","source":"@site/blog/2023-03-16-ckad-notes.md","title":"Cheat Sheet for CKAD","description":"I got my CKAD certification in Dec, 2022 and I faced difficulty memorizing all the k8s object yamls & imperative commands. Cracking CKAD needs crystal k8s concepts along with bit of a practice K8s commands. Sharing below notes taken during my preparation.","date":"2023-03-16T00:00:00.000Z","formattedDate":"March 16, 2023","tags":[{"label":"go","permalink":"/blog/tags/go"},{"label":"bittorrent","permalink":"/blog/tags/bittorrent"}],"readingTime":4.4,"hasTruncateMarker":true,"authors":[{"name":"Kundan Kumar","title":"Software Engineer at JP Morgan","url":"https://github.com/kundank78","imageURL":"https://avatars.githubusercontent.com/u/25195457"}],"frontMatter":{"slug":"cheeat-sheet-ckad","title":"Cheat Sheet for CKAD","author":"Kundan Kumar","author_url":"https://github.com/kundank78","author_title":"Software Engineer at JP Morgan","author_image_url":"https://avatars.githubusercontent.com/u/25195457","tags":["go","bittorrent"]},"nextItem":{"title":"GitHub Action for Docusaurus","permalink":"/blog/docusaurus-gh-action"}},"content":"I got my CKAD certification in Dec, 2022 and I faced difficulty memorizing all the k8s object yamls & imperative commands. Cracking CKAD needs crystal k8s concepts along with bit of a practice K8s commands. Sharing below notes taken during my preparation.\\n\\n\x3c!--truncate--\x3e\\n\\n### Setting Alias ..... A Must\\n```\\nalias k=kubectl\\n\\nexport do=\\"--dry-run=client -o yaml\\" \\nk create deploy nginx --image=nginx $do\\n\\nexport now=\\"--force --grace-period 0\\"\\nk delete pod pod_name $now\\n\\n```\\n\\n### K8s Cluster & Namespace Commands\\n- `k cluster-info`\\n- `k get nodes`\\n\\n### ReplicaSet\\n- `k get rs`\\n- `k scale --replicas=new_number rs replica_set_name`\\n\\n```yml\\n---\\napiVersion: apps/v1\\nkind: ReplicaSet\\nmetadata:\\n  name: replica_set_name\\n  labels:\\n    key: value\\nspec:\\n  replicas: no_of_pods\\n  selector:  #used to identify existing pods in env\\n    matchLabels:\\n      key: value\\n  template:\\n    metadata:\\n      name: pod_name\\n      labels:\\n        key: value\\n    spec:\\n      containers:\\n        - name: container_name\\n          image: image_name\\n```\\n\\n### Deployment\\n- k create deploy deployment_name --image=image_name --replicas=no_of_pods\\n- k scale deploy deploy_name --replicas=no_of_pods\\n- k edit deploy deploy_name                                              ----\x3e edit any field of deployment\\n- k set image deploy deploy_name container_name=nginx:1.9.1 --record     ----\x3e changed image to different version with record flag capturing cmd used\\n\\n- k rollout status deploy deploy_name\\n- k rollout history deploy deploy_name                                   ----\x3e show revisions of deployment\\n- k rollout undo deploy deploy_name                                      ----\x3e undo deployment to last revision\\n- k rollout history deploy deploy_name --revision=number                 ----\x3e describe deployment of revision number\\n- k rollout undo deploy deploy_name --to-revision=number                 ----\x3e rollback deployment to specific version\\n\\n```yml\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: deployment_name\\n  labels:\\n    key: value\\nspec:\\n  replicas: no_of_pods\\n  strategy:\\n    rollingUpdate:\\n      maxSurge: 25%\\n      maxUnavailable: 25%\\n    type: RollingUpdate\\n  selectors:\\n    matchLabels:\\n      key: value\\n  template:\\n    metadata:\\n      name: pod_name\\n      labels:\\n        key: value\\n    spec:\\n      containers:\\n        - name: container_name\\n          image: image_name\\n          ports:\\n            - containerPort: 8080\\n```\\n\\n### Namespace\\n- `k config set-context --current --namespace=namespace_name`\\n- `k port-forward svc/my-service 5000`\\n\\n```yml\\n---\\napiVersion: v1\\nkind: ResourceQuota\\nmetadata:\\n  name: compute-quota\\n  namespace: dev\\nspec:\\n  hard:\\n    pods: \\"10\\"\\n    requests:\\n      cpu: \\"4\\"\\n      memory: \\"5Gi\\"\\n    limits:\\n      cpu: \\"10\\"\\n      memory: 10Gi\\n```\\n\\n### Pods Configuration\\n\\n##### Multi container pod: share same lifecycle & network\\n- Patterns: Side Car, Ambassador, Adapter\\n\\n- POD Conditions\\n- PodScheduled -> Initialized -> ContainersReady -> Ready\\n\\n- *k logs -f pod_name container_name*               #tail logs for container_name for multi container pod\\n- *k replace -f pod.yaml --force*                   # replace existing pod with new one\\n- *k get pods -l key=value --no-headers | wc -l*    # count of pod\\n- *k get pod --show-labels*\\n- *k label po -l \\"app in(v1,v2)\\" tier=web*\\n\\n##### Taint Node\\n- *k taint node node_name key=value:taint-effect*  | Effects: NoSchedule, PreferNoSchedule, NoExecute\\n- *k taint node node_name key=value:taint-effect-* | Remove taint\\n- *k label node node_name key=value*\\n\\n```yml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: pod_name\\n  labels:\\n    key: value\\n  annotations:\\n    buildVersion: 1.34\\n  namespace: ns_name\\nspec:\\n  restartPolicy: Always                   # Always by default, Never & OnFailure\\n  serviceAccountName: service_acc_nm      # cannot be edited in pod but in deployment this can be edited and deployment will handle rollout for us\\n  automountServiceAccountToken: false     # doesn\'t mount default service account\\n  securityContext:                        # pod level security context, can be moved to container level\\n    runAsUser: 1000\\n  volumes:\\n    - name: pvc_volume\\n      persistentVolumeClaim:\\n        claimName: pvc_name\\n    - name: config_map_volume\\n      configMap:\\n        name: config_map_name\\n    - name: secret_volume                 # creates file for each key & value as secret\\n      secret:\\n        secretName: secret_name\\n    - name: empty_dir_vol                 # exists as long as pod on node disk, ram or network storage\\n      emptyDir:\\n        sizeLimit: 500Mi\\n    - name: host_volume\\n      hostPath:                           # mount file or directory from host node\'s filesystem\\n        type: Directory | DirectoryOrCreate\\n        path: /data\\n  affinity:\\n    nodeAffinity:\\n      requiredDuringSchedulingIgnoredDuringExecution:    # preferredDuringSchedulingIgnoredDuringExecution\\n        nodeSelectorTerms:\\n          - matchExpressions:\\n              - key: size\\n                operator: NotIn                          # In, NotIn, Exists, DoesNotExist, Gt and Lt.\\n                values:\\n                  - Small\\n  initContainers:\\n    - name: install\\n      image: image_name\\n  containers:\\n    - name: container_name\\n      image: image_name\\n      ports:\\n        - containerPort: port to expose\\n      command: [\\"sleep2.0\\"]               # overrides the entrypoint in docker\\n      args: [\\"10\\"]                        # adds as param in docker run cmd\\n      resources:                          # Scheduled on node if sum of requests of all container is less than node limit\\n        requests:\\n          cpu: \\"1\\"                        # \\"1\\" -> 1000m | 1m -> 1v cpu aws | If request not specified, it matches limit (same for memory)\\n          memory: \\"512Mi\\"\\n        limits:                           # container cannot exceeds its cpu limit    \\n          cpu: \\"2\\"                        # container can use more memory than limit but if it is continuous it will terminate | If limit not specified, \\n          memory: \\"1Gi\\"                     it can use all of node\'s memory and finally get killed | If limit range is defined for namespace it uses it as default\\n      securityContext:\\n        capabilities:\\n          add: [ \\"MAC_ADMIN\\" ]\\n      volumeMounts:\\n        - mountPath: /opt                 # this will be in sync\\n          name: volume_name\\n      env:                                # adding env variables\\n        - name: APP_COLOR\\n          value: pink\\n        - name: APP_COLOR\\n          valueFrom:\\n            configMapKeyRef:\\n              name: config_map_name\\n              key: KEY1\\n        - name: APP_COLOR\\n          valueFrom:\\n            secretKeyRef:\\n              name: secret_name\\n              key: KEY1\\n      envFrom:\\n        - configMapRef:\\n            name: config_map_name\\n        - secretRef:\\n            name: secret_name\\n      tolerations:\\n        - key: \\"app\\"\\n          operator: \\"Equal\\"\\n          value: \\"blue\\"\\n          effect: \\"NoSchedule\\"\\n      nodeSelector:                         # label node with same\\n        key: value\\n      readinessProbe:\\n        periodSeconds: 5\\n        initialDelaySeconds: 15\\n        failureThreshold: 8\\n        httpGet:\\n          path: /api/ready\\n          port: 5000\\n        tcpSocket:\\n          port: 8080\\n        exec:\\n          command:\\n            - cat\\n            - /app/is_ready\\n      livenessProbe:\\n        periodSeconds: 5\\n        initialDelaySeconds: 15\\n        failureThreshold: 8\\n        httpGet:\\n          path: /api/ready\\n          port: 5000\\n        tcpSocket:\\n          port: 8080\\n        exec:\\n          command:\\n            - cat\\n            - /app/is_ready\\n```\\n\\n### Config Map\\n\\n- *k create configmap config_map_name --from-literal=KEY1=VALUE1 --from-literal=KEY2=VALUE2*\\n- *k create configmap config_map_name --from-file=file_name.properties*\\n\\n```yml\\n---\\napiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: config_map_name\\nspec:\\n  key1: value1\\n  key2: value2\\n```"},{"id":"docusaurus-gh-action","metadata":{"permalink":"/blog/docusaurus-gh-action","source":"@site/blog/2021-01-17-docusaurus-gh-action.md","title":"GitHub Action for Docusaurus","description":"I got tired of deploying my Docusaurus website to GitHub Pages manually, and decided to do something about it using GitHub Action.","date":"2021-01-17T00:00:00.000Z","formattedDate":"January 17, 2021","tags":[{"label":"docusaurus","permalink":"/blog/tags/docusaurus"},{"label":"github-action","permalink":"/blog/tags/github-action"},{"label":"ci","permalink":"/blog/tags/ci"}],"readingTime":1.485,"hasTruncateMarker":true,"authors":[{"name":"Kundan Kumar","title":"Software Engineer at JP Morgan","url":"https://github.com/kundank78","imageURL":"https://avatars.githubusercontent.com/u/25195457"}],"frontMatter":{"slug":"docusaurus-gh-action","title":"GitHub Action for Docusaurus","author":"Kundan Kumar","author_url":"https://github.com/kundank78","author_title":"Software Engineer at JP Morgan","author_image_url":"https://avatars.githubusercontent.com/u/25195457","tags":["docusaurus","github-action","ci"]},"prevItem":{"title":"Cheat Sheet for CKAD","permalink":"/blog/cheeat-sheet-ckad"}},"content":"I got tired of deploying my Docusaurus website to GitHub Pages manually, and decided to do something about it using GitHub Action.\\n\\nInitially, I was planning to follow the [official guide](https://v2.docusaurus.io/docs/deployment#triggering-deployment-with-github-actions) on doing so. However, it was actually much more complicated than I liked. I did not really want to generate and store a SSH key on GitHub. Too much effort man.\\n\\nI decided it was better off for me to write my own script. Here it is:\\n\\n\x3c!--truncate--\x3e\\n\\n## deploy-docusaurus.yml\\n\\n:::caution\\n\\nThe script below assumes that your Docusaurus website resides at `/website` of your repo. If that is not the case for you, you will need to:\\n\\n- Change `cd website` to `cd <docu_site_root>`, or delete the entire line if your Docusaurus website is at the root of your repo `/`\\n- Change `build_dir`\'s value from `website/build` to `<docu_site_root>/build`, or `build` if your Docusaurus website is at the root of your repo `/`\\n\\n:::\\n\\n```yml\\nname: deploy-docusaurus\\n\\non:\\n  push:\\n    branches: [main]\\n  pull_request:\\n    branches: [main]\\n\\n  # Allows you to run this workflow manually from the Actions tab\\n  workflow_dispatch:\\n\\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\\njobs:\\n  publish:\\n    runs-on: ubuntu-latest\\n    steps:\\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\\n      - name: Check out repo\\n        uses: actions/checkout@v2\\n      # Node is required for npm\\n      - name: Set up Node\\n        uses: actions/setup-node@v2\\n        with:\\n          node-version: \\"12\\"\\n      # Install and build Docusaurus website\\n      - name: Build Docusaurus website\\n        run: |\\n          cd website\\n          npm install \\n          npm run build\\n      - name: Deploy to GitHub Pages\\n        if: success()\\n        uses: crazy-max/ghaction-github-pages@v2\\n        with:\\n          target_branch: gh-pages\\n          build_dir: website/build\\n        env:\\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\\n```\\n\\n:::note\\n\\nGitHub will automatically add `GITHUB_TOKEN` to Secrets. You need not do so. See [this](https://docs.github.com/en/actions/reference/authentication-in-a-workflow) for more information.\\n\\n:::"}]}')}}]);